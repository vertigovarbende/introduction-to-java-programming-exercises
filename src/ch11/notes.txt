notes

// more in subclass
# Contrary to the conventional interpretation, a subclass is not a subset of its superclass. 
In fact, a subclass usually contains more information and methods than its superclass.


// private data fields
# Private data fields in a superclass are not accessible outside the class. Therefore, 
they cannot be used directly in a subclass. They can, however, be accessed/mutated 
through public accessors/mutators if defined in the superclass

// nonextensible-is-a
# Not all is-a relationships should be modeled using inheritance. For example, a square 
is a rectangle, but you should not extend a Square class from a Rectangle class, 
because the width and height properties are not appropriate for a square. Instead, 
you should define a Square class to extend the GeometricObject class and define 
the side property for the side of a square

// no blind extension
# Inheritance is used to model the is-a relationship. Do not blindly extend a class just 
for the sake of reusing methods. For example, it makes no sense for a Tree class to 
extend a Person class, even though they share common properties such as height 
and weight. A subclass and its superclass must have the is-a relationship

// single inheritance - multiple inheritance
# Some programming languages allow you to derive a subclass from several classes. 
This capability is known as multiple inheritance. Java, however, does not allow multiple inheritance. 
A Java class may inherit directly from only one superclass. This 
restriction is known as single inheritance. If you use the extends keyword to define 
a subclass, it allows only one parent class. Nevertheless, multiple inheritance can be 
achieved through interfaces

// super
# You must use the keyword super to call the superclass constructor, and the call must 
be the first statement in the constructor. Invoking a superclass constructor’s name in a 
subclass causes a syntax error.

// no-arg constructor
# If a class is designed to be extended, it is better to provide a no-arg constructor to avoid 
programming errors. 

// override accessible instance method
# An instance method can be overridden only if it is accessible. 
Thus a private method cannot be overridden, because it is not accessible outside its own class. 
If a method defined in a subclass is private in its superclass, the two methods are completely unrelated.

// cannot override static method
# Like an instance method, a static method can be inherited. However, a static method 
cannot be overridden. If a static method defined in the superclass is redefined in a 
subclass, the method defined in the superclass is hidden. The hidden static methods 
can be invoked using the syntax SuperClassName.staticMethodName.

// overloading vs overriding
# Overridden methods are in different classes related by inheritance; 
overloaded methods can be either in the same class or different classes related by inheritance.

# Overridden methods have the same signature and return type; overloaded methods 
have the same name but a different parameter list


// dynamic-binding - declared type - actual type
# declared type and actual type. A variable must be declared a type. The type that 
declares a variable is called the variable’s declared type. Here o’s declared type is Object. A 
variable of a reference type can hold a null value or a reference to an instance of the declared 
type. The instance may be created using the constructor of the declared type or its subtype. 
The actual type of the variable is the actual class for the object referenced by the variable. 
Here o’s actual type is GeometricObject, because o references an object created using new
GeometricObject(). Which toString() method is invoked by o is determined by o’s
actual type. This is known as dynamic binding.

// '==' vs '.equals()'
# The == comparison operator is used for comparing two primitive data type values or 
for determining whether two objects have the same references. The equals method is 
intended to test whether two objects have the same contents, provided that the method 
is overridden in the defining class of the objects. The == operator is stronger than the 
equals method, in that the == operator checks whether the two reference variables 
refer to the same object

// 'equals()' method
# Using the signature equals(SomeClassName obj) (e.g., equals(Circle c))
to override the equals method in a subclass is a common mistake. You should use 
equals(Object obj). See CheckPoint Question 11.29
#  When overriding the equals method, a common mistake is mistyping its signature
in the subclass. For example, the equals method is incorrectly written as 
equals(Circle circle), as shown in (a) in following the code; instead, it should 
be equals(Object circle), as shown in (b). Show the output of running class 
Test with the Circle class in (a) and in (b), respectively

// sorting in arrays and arraylists
# Note that you can sort an array using the java.util.
Arrays.sort(array) method. To sort an array list, use the java.util.Collections.
sort(arraylist) method

// 'protected'
# A subclass may override a protected method defined in its superclass and change its 
visibility to public. However, a subclass cannot weaken the accessibility of a method 
defined in the superclass. For example, if a method is defined as public in the superclass, 
it must be defined as public in the subclass.

// 'final'
# Neither a final class nor a final method can be extended. A final data field is a 
constant.
# The modifiers public, protected, private, static, abstract, and final are 
used on classes and class members (data and methods), except that the final modifier 
can also be used on local variables in a method. A final local variable is a constant 
inside a method.



